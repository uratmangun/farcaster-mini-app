name: Deploy to Cloudflare Pages and Deno Deploy

on:
  push:
    branches: [main, master]
    paths:
      - 'app/**'
      - 'public/**'
      - 'functions/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'deno.json'
      - 'vite.config.ts'
      - 'tsconfig.json'
      - 'tailwind.config.*'
      - '.github/workflows/deploy-cloudflare.yml'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  deployments: write
  pull-requests: write

jobs:
  deploy-deno:
    runs-on: ubuntu-latest
    name: Deploy to Deno Deploy
    outputs:
      url: ${{ steps.deno-deploy.outputs.url }}
      deno_url: ${{ steps.deno-status.outputs.deno_url }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Deno
        uses: denoland/setup-deno@v1
        with:
          deno-version: v2.x

      - name: Check Deno version
        run: |
          echo "üìã Deno version information:"
          deno --version

      - name: Verify Deno functions
        run: |
          echo "üîç Checking Deno functions..."
          deno check functions/*.ts
          echo "‚úÖ All functions type-checked successfully"

      - name: Test Deno functions
        run: |
          echo "üß™ Testing function imports..."
          deno run --allow-net --allow-env --allow-read functions/router.ts &
          SERVER_PID=$!
          sleep 3

          # Test if server is responding
          if curl -f http://localhost:8000/ > /dev/null 2>&1; then
            echo "‚úÖ Router is responding correctly"
          else
            echo "‚ùå Router test failed"
            exit 1
          fi

          # Clean up
          kill $SERVER_PID || true
          wait $SERVER_PID 2>/dev/null || true

      - name: Generate Deno Deploy project name
        id: deno_project_name
        run: |
          # Extract repository name from GitHub context
          REPO_NAME="${{ github.event.repository.name }}"
          
          # Generate random alphanumeric string (6 chars to avoid 8/12 char restriction)
          RANDOM_ID=$(openssl rand -hex 3)
          
          # Truncate repo name to ensure total length <= 26 chars
          # Format: {truncated-repo-name}-{6-char-random}
          # Max repo name length: 26 - 1 (hyphen) - 6 (random) = 19 chars
          TRUNCATED_REPO=$(echo "$REPO_NAME" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g' | sed -E 's/^-+|-+$//g' | cut -c1-19)
          
          # Create project name
          PROJECT_NAME="${TRUNCATED_REPO}-${RANDOM_ID}"
          
          # Final validation: ensure length <= 26 and doesn't start/end with hyphen
          PROJECT_NAME=$(echo "$PROJECT_NAME" | sed -E 's/^-+|-+$//g' | cut -c1-26)

          echo "üìÅ Repository name: '$REPO_NAME'"
          echo "‚úÇÔ∏è  Truncated repo name: '$TRUNCATED_REPO'"
          echo "üé≤ Random ID: '$RANDOM_ID'"
          echo "üöÄ Generated project name: '$PROJECT_NAME' (${#PROJECT_NAME} chars)"
          echo "deno_project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT

      - name: Install Deno Deploy CLI
        run: |
          # Install deployctl using the current JSR registry (recommended method)
          echo "üì¶ Installing deployctl from JSR..."
          deno install -gArf jsr:@deno/deployctl

          # Verify installation
          echo "‚úÖ deployctl installed successfully"
          deployctl --version

      - name: Create Deno Deploy project if not exists
        run: |
          if [ -z "${{ secrets.DENO_DEPLOY_TOKEN }}" ]; then
            echo "‚ùå DENO_DEPLOY_TOKEN not set, cannot proceed with deployment"
            echo "üí° To enable Deno Deploy:"
            echo "   1. Generate token at: https://dash.deno.com/account/access-tokens"
            echo "   2. Add DENO_DEPLOY_TOKEN to repository secrets"
            exit 1
          fi
          
          PROJECT_NAME="${{ steps.deno_project_name.outputs.deno_project_name }}"
          REPO_NAME="${{ github.event.repository.name }}"
          echo "üîç Preparing Deno Deploy project: ${PROJECT_NAME}"
          echo "üìÅ Repository name prefix: ${REPO_NAME}"
          
          # Set non-interactive mode to prevent browser authorization prompts
          export DENO_DEPLOY_TOKEN="${{ secrets.DENO_DEPLOY_TOKEN }}"
          
          # First, try to list projects to verify token works
          echo "üîê Verifying token access..."
          if ! deployctl projects list --token="${DENO_DEPLOY_TOKEN}" >/dev/null 2>&1; then
            echo "‚ùå Token verification failed. Please check DENO_DEPLOY_TOKEN secret."
            echo "üí° Generate a new token at: https://dash.deno.com/account/access-tokens"
            exit 1
          fi
          echo "‚úÖ Token verified successfully"
          
          # Cleanup phase: Delete all existing projects with the same base name prefix
          # Extract base name from PROJECT_NAME (remove the last 5 characters which is the random ID)
          PROJECT_BASE="${PROJECT_NAME%-*}"
          
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üßπ CLEANUP PHASE: Removing old projects"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üîç Looking for projects with prefix: ${PROJECT_BASE}-"
          echo ""
          
          # Get list of all projects using JSON output for better parsing
          echo "üìã Fetching project list from Deno Deploy..."
          PROJECT_LIST_OUTPUT=$(deployctl projects list --token="${DENO_DEPLOY_TOKEN}" 2>&1)
          PROJECT_LIST_EXIT_CODE=$?
          
          if [ $PROJECT_LIST_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è Warning: Failed to list projects (exit code: $PROJECT_LIST_EXIT_CODE)"
            echo "üìù Output: $PROJECT_LIST_OUTPUT"
          else
            echo "‚úÖ Successfully retrieved project list"
            
            # The deployctl output is typically in a table format. We need to extract just the project names
            # Skip header lines and extract the first column (project name)
            MATCHING_PROJECTS=$(echo "$PROJECT_LIST_OUTPUT" | tail -n +3 | awk '{print $1}' | grep "^${PROJECT_BASE}-" || true)
            
            # Count matching projects
            MATCH_COUNT=$(echo "$MATCHING_PROJECTS" | grep -c "^${PROJECT_BASE}-" || echo "0")
            
            if [ "$MATCH_COUNT" -gt 0 ]; then
              echo "üéØ Found ${MATCH_COUNT} project(s) to delete:"
              echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
              echo "$MATCHING_PROJECTS" | while IFS= read -r proj; do
                [ -n "$proj" ] && echo "  ‚Ä¢ $proj"
              done
              echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
              echo ""
              
              # Delete each matching project with retry logic
              DELETION_FAILURES=0
              echo "$MATCHING_PROJECTS" | while IFS= read -r project_to_delete; do
                if [ -n "$project_to_delete" ]; then
                  echo "üóëÔ∏è  Attempting to delete: $project_to_delete"
                  
                  # Try to delete with retry logic
                  RETRY_COUNT=0
                  MAX_RETRIES=3
                  DELETE_SUCCESS=false
                  
                  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                    DELETE_OUTPUT=$(deployctl projects delete "$project_to_delete" --token="${DENO_DEPLOY_TOKEN}" --force 2>&1)
                    DELETE_EXIT_CODE=$?
                    
                    if [ $DELETE_EXIT_CODE -eq 0 ]; then
                      echo "   ‚úÖ Successfully deleted: $project_to_delete"
                      DELETE_SUCCESS=true
                      break
                    else
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                      
                      # Check if project doesn't exist (already deleted)
                      if echo "$DELETE_OUTPUT" | grep -qi "not found\|does not exist\|404"; then
                        echo "   ‚ÑπÔ∏è  Project doesn't exist (may have been already deleted): $project_to_delete"
                        DELETE_SUCCESS=true
                        break
                      fi
                      
                      if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                        echo "   ‚ö†Ô∏è  Deletion attempt $RETRY_COUNT failed, retrying..."
                        echo "   üìù Error: $DELETE_OUTPUT"
                        sleep 2
                      else
                        echo "   ‚ùå Failed to delete after $MAX_RETRIES attempts: $project_to_delete"
                        echo "   üìù Last error: $DELETE_OUTPUT"
                        DELETION_FAILURES=$((DELETION_FAILURES + 1))
                      fi
                    fi
                  done
                fi
              done
              
              if [ $DELETION_FAILURES -gt 0 ]; then
                echo ""
                echo "‚ö†Ô∏è  Warning: Failed to delete $DELETION_FAILURES project(s)"
                echo "   These may need manual cleanup in the Deno Deploy dashboard"
              else
                echo ""
                echo "‚úÖ All matching projects deleted successfully"
              fi
              
              # Wait longer for deletions to fully propagate
              echo "‚è≥ Waiting 5 seconds for deletions to propagate..."
              sleep 5
            else
              echo "‚úÖ No existing projects found with prefix '${REPO_NAME}-'"
            fi
          fi
          
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üöÄ PROJECT CREATION PHASE"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          # Verify cleanup was successful by checking again
          echo "üîç Verifying cleanup completion..."
          VERIFY_LIST=$(deployctl projects list --token="${DENO_DEPLOY_TOKEN}" 2>&1 | tail -n +3 | awk '{print $1}' | grep "^${PROJECT_NAME}$" || true)
          
          if [ -n "$VERIFY_LIST" ]; then
            echo "‚ö†Ô∏è  Warning: Project ${PROJECT_NAME} still exists, attempting force deletion..."
            deployctl projects delete "${PROJECT_NAME}" --token="${DENO_DEPLOY_TOKEN}" --force 2>&1
            sleep 3
          fi
          
          # Now create the new project with retry logic
          echo "üöÄ Creating new project: ${PROJECT_NAME}"
          
          CREATE_RETRY=0
          CREATE_MAX_RETRIES=3
          CREATE_SUCCESS=false
          
          while [ $CREATE_RETRY -lt $CREATE_MAX_RETRIES ]; do
            CREATE_OUTPUT=$(deployctl projects create "${PROJECT_NAME}" --token="${DENO_DEPLOY_TOKEN}" 2>&1)
            CREATE_EXIT_CODE=$?
            
            if [ $CREATE_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Project created successfully: ${PROJECT_NAME}"
              CREATE_SUCCESS=true
              break
            else
              CREATE_RETRY=$((CREATE_RETRY + 1))
              
              # Check if project already exists
              if echo "$CREATE_OUTPUT" | grep -qi "already exists\|name already exists\|409"; then
                echo "‚ÑπÔ∏è  Project already exists, using existing project: ${PROJECT_NAME}"
                CREATE_SUCCESS=true
                break
              fi
              
              if [ $CREATE_RETRY -lt $CREATE_MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  Creation attempt $CREATE_RETRY failed, retrying..."
                echo "üìù Error: $CREATE_OUTPUT"
                sleep 3
              else
                echo "‚ùå Failed to create project after $CREATE_MAX_RETRIES attempts"
                echo "üìù Last error: $CREATE_OUTPUT"
              fi
            fi
          done
          
          if [ "$CREATE_SUCCESS" != "true" ]; then
            echo "‚ùå Project creation failed. Check token permissions and try again."
            exit 1
          fi
          
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "‚úÖ PROJECT SETUP COMPLETE"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        env:
          DENO_DEPLOY_TOKEN: ${{ secrets.DENO_DEPLOY_TOKEN }}

      - name: Deploy to Deno Deploy
        id: deno-deploy
        run: |
          PROJECT_NAME="${{ steps.deno_project_name.outputs.deno_project_name }}"
          echo "üöÄ Deploying to Deno Deploy project: ${PROJECT_NAME}"
          
          # Deploy with retry logic for network errors
          MAX_RETRIES=3
          RETRY_COUNT=0
          DEPLOY_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "üì§ Deployment attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."
            set +e  # Don't exit on error so we can capture both streams
            
            # Add timeout and include verbose output for debugging
            DEPLOY_STDOUT=$(timeout 300 deployctl deploy \
              --project="${PROJECT_NAME}" \
              --token="${{ secrets.DENO_DEPLOY_TOKEN }}" \
              --prod \
              functions/router.ts 2>/tmp/deploy_stderr)
            DEPLOY_EXIT_CODE=$?
            DEPLOY_STDERR=$(cat /tmp/deploy_stderr 2>/dev/null || echo "")
            
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            echo "üìã DEPLOYMENT OUTPUT (Attempt $((RETRY_COUNT + 1)))"
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            echo "Exit Code: $DEPLOY_EXIT_CODE"
            echo ""
            echo "üì§ STDOUT:"
            echo "$DEPLOY_STDOUT"
            echo ""
            echo "‚ö†Ô∏è  STDERR:"
            echo "$DEPLOY_STDERR"
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            
            # Check for success
            if [ $DEPLOY_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Deployment successful on attempt $((RETRY_COUNT + 1))"
              DEPLOY_SUCCESS=true
              break
            fi
            
            # Check for specific network errors
            if echo "$DEPLOY_STDERR" | grep -qi "error reading a body from connection\|network\|timeout\|connection reset"; then
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  Network error detected, retrying in 10 seconds..."
                sleep 10
              fi
            else
              # Non-network error, fail immediately
              echo "‚ùå Non-network error detected, stopping retries"
              break
            fi
          done
          
          if [ "$DEPLOY_SUCCESS" != "true" ]; then
            echo "‚ùå Deployment failed after $MAX_RETRIES attempts"
            exit 1
          fi
          
          # Extract deployment URL from output - look for the production URL
          DEPLOY_URL=$(echo "$DEPLOY_OUTPUT" | grep -oE 'https://[^[:space:]]+\.deno\.dev[^[:space:]]*' | head -1)
          
          # If no URL found, construct it from project name
          if [ -z "$DEPLOY_URL" ]; then
            echo "‚ö†Ô∏è No URL found in output, constructing from project name"
            DEPLOY_URL="https://${PROJECT_NAME}.deno.dev"
          fi
          
          echo "‚úÖ Deployment successful"
          echo "üìç Deployment URL: $DEPLOY_URL"
          echo "url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          
          # Verify the deployment is accessible
          echo "üîç Verifying deployment is accessible..."
          sleep 5  # Give deployment a moment to propagate
          if curl -f "$DEPLOY_URL" > /dev/null 2>&1; then
            echo "‚úÖ Deployment is accessible at $DEPLOY_URL"
          else
            echo "‚ö†Ô∏è Deployment may still be propagating"
          fi
        env:
          DENO_DEPLOY_TOKEN: ${{ secrets.DENO_DEPLOY_TOKEN }}

      - name: Log Deno Deploy Status
        id: deno-status
        run: |
          DENO_URL="${{ steps.deno-deploy.outputs.url }}"
          if [ -n "$DENO_URL" ]; then
            echo "‚úÖ Deno Deploy successful: $DENO_URL"
            echo "deno_url=$DENO_URL" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Deno Deploy failed - no URL returned"
            echo "üí° Check deployment logs for issues"
            exit 1
          fi

  deploy-cloudflare:
    runs-on: ubuntu-latest
    name: Deploy to Cloudflare Pages
    needs: deploy-deno
    outputs:
      url: ${{ steps.cloudflare-deploy.outputs.url }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Cloudflare Pages project name
        id: cloudflare_project_name
        run: |
          # Extract repository name from GitHub context
          REPO_NAME="${{ github.event.repository.name }}"
          
          # Truncate repo name to 26 chars to leave room for random ID
          TRUNCATED_REPO=$(echo "$REPO_NAME" | cut -c1-26)
          
          # Generate random alphanumeric string (4 chars)
          RANDOM_ID=$(openssl rand -hex 2)
          
          # Create unique project name with format: {truncated-repo-name}-{random}
          PROJECT_NAME="${TRUNCATED_REPO}-${RANDOM_ID}"
          
          # Ensure project name is valid (lowercase, alphanumeric with hyphens, max 63 chars)
          PROJECT_NAME=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g')
          # Remove any leading or trailing hyphens
          PROJECT_NAME=$(echo "$PROJECT_NAME" | sed -E 's/^-+|-+$//g' | cut -c1-63)
          
          echo "üìÅ Repository name: '$REPO_NAME'"
          echo "‚úÇÔ∏è  Truncated repo name: '$TRUNCATED_REPO'"
          echo "üé≤ Random ID: '$RANDOM_ID'"
          echo "üöÄ Generated project name: '$PROJECT_NAME' (${#PROJECT_NAME} chars)"
          echo "cloudflare_project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "PROJECT_SLUG=$PROJECT_NAME" >> "$GITHUB_ENV"

      - name: Run project configuration scripts
        env:
          FARCASTER_FID: ${{ secrets.FARCASTER_FID }}
          FARCASTER_PRIVATE_KEY: ${{ secrets.FARCASTER_PRIVATE_KEY }}
          
        run: |
          PROJECT_NAME="${{ steps.cloudflare_project_name.outputs.cloudflare_project_name }}"
          FARCASTER_DOMAIN="https://${PROJECT_NAME}.pages.dev"
          
          echo "üîß Running configuration scripts with:"
          echo "   PROJECT_NAME=${PROJECT_NAME}"
          echo "   FARCASTER_DOMAIN=${FARCASTER_DOMAIN}"
          
          # Export environment variables for scripts
          export FARCASTER_DOMAIN="${FARCASTER_DOMAIN}"
          export PROJECT_NAME="${PROJECT_NAME}"
                      
          # Run generate-farcaster-auth.js
          echo "üîê Running generate-farcaster-auth.js..."
          node scripts/generate-farcaster-auth.js
          
          # Run generate-flux-images.js
          echo "üé® Running generate-flux-images.js..."
          node scripts/generate-flux-images.js

          # Run generate-meta-config.js
          echo "üìù Running generate-meta-config.js..."
          node scripts/generate-meta-config.js
          
          echo "‚úÖ All configuration scripts completed"

      - name: Build Remix SPA for Cloudflare Pages
        run: |
          DENO_URL="${{ needs.deploy-deno.outputs.url }}"
          echo "üîó Received Deno Deploy URL: ${DENO_URL}"
          
          # Verify we have a valid URL - fail if not
          if [ -z "${DENO_URL}" ] || [ "${DENO_URL}" = "" ]; then
            echo "‚ùå ERROR: No Deno Deploy URL received from previous job"
            echo "‚ùå The Deno deployment must complete successfully before building the Remix SPA"
            echo "üí° Check the 'deploy-deno' job logs for deployment issues"
            exit 1
          fi
          
          # Export the environment variable for Vite
          export VITE_API_BASE_URL="${DENO_URL}"
          
          echo "üì¶ Building SPA with environment:"
          echo "   VITE_API_BASE_URL=${VITE_API_BASE_URL}"
          
          # Create .env.production file for Vite
          echo "VITE_API_BASE_URL=${VITE_API_BASE_URL}" > .env.production
          echo "üìù Created .env.production with API URL"
          cat .env.production
          
          # Build the SPA for Cloudflare Pages
          echo "üî® Starting SPA build for Cloudflare Pages..."
          VITE_API_BASE_URL="${VITE_API_BASE_URL}" pnpm build
          
          # Verify the build output
          echo "üîç Verifying SPA build output..."
          echo "üìÇ Build structure:"
          ls -la build/ || echo "No build directory found"
          
          # Check for client build (SPA only needs client)
          if [ -d "build/client" ]; then
            echo "‚úÖ Client build found"
            ls -la build/client/ || true
          else
            echo "‚ùå Error: No client build found"
            exit 1
          fi
          
          echo "‚úÖ SPA build completed"

      # Removed: Setup Cloudflare Pages Functions (not needed for SPA)

      - name: Create Cloudflare Pages project with cleanup
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CI: true
        run: |
          set -e
          echo "Wrangler version:"; pnpm dlx wrangler --version
          test -n "$CLOUDFLARE_ACCOUNT_ID" || { echo "CLOUDFLARE_ACCOUNT_ID is empty"; exit 1; }
          test -n "$CLOUDFLARE_API_TOKEN" || { echo "CLOUDFLARE_API_TOKEN is empty"; exit 1; }
          
          PROJECT_NAME="${{ steps.cloudflare_project_name.outputs.cloudflare_project_name }}"
          REPO_NAME="${{ github.event.repository.name }}"
          echo "üîç Preparing Cloudflare Pages project: ${PROJECT_NAME}"
          
          # Extract base name from PROJECT_NAME (remove the last 5 characters which is the random ID)
          PROJECT_BASE="${PROJECT_NAME%-*}"
          echo "üìÅ Project base name for cleanup: ${PROJECT_BASE}"
          
          # Cleanup phase: Delete all existing projects with the same base name prefix
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üßπ CLEANUP PHASE: Removing old Cloudflare Pages projects"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üîç Looking for projects with prefix: ${PROJECT_BASE}-"
          echo ""
          
          # Get list of all projects
          echo "üìã Fetching project list from Cloudflare Pages..."
          PROJECT_LIST_OUTPUT=$(pnpm dlx wrangler pages project list 2>&1)
          PROJECT_LIST_EXIT_CODE=$?
          
          if [ $PROJECT_LIST_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è Warning: Failed to list projects (exit code: $PROJECT_LIST_EXIT_CODE)"
            echo "üìù Output: $PROJECT_LIST_OUTPUT"
            echo "‚ö†Ô∏è Proceeding without cleanup..."
          else
            echo "‚úÖ Successfully retrieved project list"
            
            # Extract project names from the table output
            # The output has table format with ‚îÇ separators, extract first column
            MATCHING_PROJECTS=$(echo "$PROJECT_LIST_OUTPUT" | grep "‚îÇ" | awk -F'‚îÇ' '{print $2}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep "^${REPO_NAME}-" || true)
            
            # Count matching projects
            MATCH_COUNT=$(echo "$MATCHING_PROJECTS" | grep -c "^${REPO_NAME}-" || echo "0")
            
            if [ "$MATCH_COUNT" -gt 0 ]; then
              echo "üéØ Found ${MATCH_COUNT} project(s) to delete:"
              echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
              echo "$MATCHING_PROJECTS" | while IFS= read -r proj; do
                [ -n "$proj" ] && echo "  ‚Ä¢ $proj"
              done
              echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
              echo ""
              
              # Delete each matching project with retry logic
              DELETION_FAILURES=0
              echo "$MATCHING_PROJECTS" | while IFS= read -r project_to_delete; do
                if [ -n "$project_to_delete" ]; then
                  echo "üóëÔ∏è  Attempting to delete: $project_to_delete"
                  
                  # Try to delete with retry logic
                  RETRY_COUNT=0
                  MAX_RETRIES=3
                  DELETE_SUCCESS=false
                  
                  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                    DELETE_OUTPUT=$(pnpm dlx wrangler pages project delete "$project_to_delete" --yes 2>&1)
                    DELETE_EXIT_CODE=$?
                    
                    if [ $DELETE_EXIT_CODE -eq 0 ]; then
                      echo "   ‚úÖ Successfully deleted: $project_to_delete"
                      DELETE_SUCCESS=true
                      break
                    else
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                      
                      # Check if project doesn't exist (already deleted)
                      if echo "$DELETE_OUTPUT" | grep -qi "not found\|does not exist\|404"; then
                        echo "   ‚ÑπÔ∏è  Project doesn't exist (may have been already deleted): $project_to_delete"
                        DELETE_SUCCESS=true
                        break
                      fi
                      
                      if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                        echo "   ‚ö†Ô∏è  Deletion attempt $RETRY_COUNT failed, retrying..."
                        echo "   üìù Error: $DELETE_OUTPUT"
                        sleep 2
                      else
                        echo "   ‚ùå Failed to delete after $MAX_RETRIES attempts: $project_to_delete"
                        echo "   üìù Last error: $DELETE_OUTPUT"
                        DELETION_FAILURES=$((DELETION_FAILURES + 1))
                      fi
                    fi
                  done
                fi
              done
              
              if [ $DELETION_FAILURES -gt 0 ]; then
                echo ""
                echo "‚ö†Ô∏è  Warning: Failed to delete $DELETION_FAILURES project(s)"
                echo "   These may need manual cleanup in the Cloudflare Pages dashboard"
              else
                echo ""
                echo "‚úÖ All matching projects deleted successfully"
              fi
              
              # Wait for deletions to propagate
              echo "‚è≥ Waiting 5 seconds for deletions to propagate..."
              sleep 5
            else
              echo "‚úÖ No existing projects found with prefix '${REPO_NAME}-'"
            fi
          fi
          
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üöÄ PROJECT CREATION PHASE"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          # Verify cleanup was successful by checking again
          echo "üîç Verifying cleanup completion..."
          VERIFY_LIST=$(pnpm dlx wrangler pages project list 2>&1 | grep "‚îÇ" | awk -F'‚îÇ' '{print $2}' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep "^${PROJECT_NAME}$" || true)
          
          if [ -n "$VERIFY_LIST" ]; then
            echo "‚ö†Ô∏è  Warning: Project ${PROJECT_NAME} still exists, attempting force deletion..."
            pnpm dlx wrangler pages project delete "${PROJECT_NAME}" --yes 2>&1
            sleep 3
          fi
          
          # Now create the new project with retry logic
          echo "üöÄ Creating new project: ${PROJECT_NAME}"
          
          CREATE_RETRY=0
          CREATE_MAX_RETRIES=3
          CREATE_SUCCESS=false
          
          while [ $CREATE_RETRY -lt $CREATE_MAX_RETRIES ]; do
            CREATE_OUTPUT=$(pnpm dlx wrangler pages project create "${PROJECT_NAME}" --production-branch=main 2>&1)
            CREATE_EXIT_CODE=$?
            
            if [ $CREATE_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Project created successfully: ${PROJECT_NAME}"
              CREATE_SUCCESS=true
              break
            else
              CREATE_RETRY=$((CREATE_RETRY + 1))
              
              # Check if project already exists
              if echo "$CREATE_OUTPUT" | grep -qi "already exists\|name already exists\|409"; then
                echo "‚ÑπÔ∏è  Project already exists, using existing project: ${PROJECT_NAME}"
                CREATE_SUCCESS=true
                break
              fi
              
              if [ $CREATE_RETRY -lt $CREATE_MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  Creation attempt $CREATE_RETRY failed, retrying..."
                echo "üìù Error: $CREATE_OUTPUT"
                sleep 3
              else
                echo "‚ùå Failed to create project after $CREATE_MAX_RETRIES attempts"
                echo "üìù Last error: $CREATE_OUTPUT"
              fi
            fi
          done
          
          if [ "$CREATE_SUCCESS" != "true" ]; then
            echo "‚ùå Project creation failed. Check API token permissions (Account: Cloudflare Pages: Read, Edit) and try again."
            exit 1
          fi
          
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "‚úÖ PROJECT SETUP COMPLETE"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

      - name: Deploy SPA to Cloudflare Pages (wrangler v3 deploy)
        id: cloudflare-deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          set -e
          echo "Wrangler version:"; pnpm dlx wrangler --version
          
          # For SPA deployment, we only need the client build
          echo "üì¶ Preparing SPA deployment..."
          
          # Verify client build exists
          if [ ! -d "build/client" ]; then
            echo "‚ùå Error: Client build not found"
            exit 1
          fi
          
          echo "üìÇ Deployment files:"
          ls -la build/client/ | head -20
          
          echo "üöÄ Deploying SPA project '${PROJECT_SLUG}' to Cloudflare Pages..."
          # Deploy the client build directory directly
          DEPLOY_OUT=$(pnpm dlx wrangler pages deploy build/client --project-name "${PROJECT_SLUG}" 2>&1) || {
            echo "$DEPLOY_OUT"
            exit 1
          }
          echo "$DEPLOY_OUT"
          
          # Extract first pages.dev URL from output
          URL=$(echo "$DEPLOY_OUT" | grep -Eo 'https?://[^ ]+\.pages\.dev[^ ]*' | head -n1)
          if [ -n "$URL" ]; then
            echo "url=$URL" >> "$GITHUB_OUTPUT"
            echo "‚úÖ SPA Deployment URL: $URL"
          else
            echo "‚ö†Ô∏è Warning: No deployment URL found in wrangler output" >&2
          fi

      - name: Update Repository Homepage URL
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            let deploymentUrl = '${{ steps.cloudflare-deploy.outputs.url }}';
            
            // Remove the random string prefix from Cloudflare Pages URL
            // Format: https://{random}.{project-name}.pages.dev -> https://{project-name}.pages.dev
            if (deploymentUrl && deploymentUrl.includes('.pages.dev')) {
              const urlParts = deploymentUrl.split('.');
              if (urlParts.length >= 4) {
                // Remove the random subdomain, keep the project name subdomain
                deploymentUrl = `https://${urlParts[1]}.pages.dev`;
              }
            }
            
            if (deploymentUrl && deploymentUrl !== '') {
              try {
                await github.rest.repos.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  homepage: deploymentUrl,
                  description: 'Remix SPA ‚Äì Cloudflare Pages deployment'
                });
                
                console.log(`‚úÖ Repository homepage updated to: ${deploymentUrl}`);
              } catch (error) {
                console.error('‚ùå Failed to update repository homepage:', error);
                core.setFailed(`Failed to update homepage: ${error.message}`);
              }
            } else {
              console.log('‚ö†Ô∏è No deployment URL found, skipping homepage update');
            }

      - name: Create GitHub deployment
        if: always()
        id: create-deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Cloudflare Pages deployment',
              auto_merge: false,
              required_contexts: []
            });
            
            return deployment.data.id;

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const deploymentUrl = '${{ steps.cloudflare-deploy.outputs.url }}';
            const state = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            const deploymentId = ${{ steps.create-deployment.outputs.result }};
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deploymentId,
              state: state,
              environment_url: deploymentUrl || '',
              description: state === 'success' ? 'Deployment succeeded' : 'Deployment failed'
            });

      - name: Comment on PR with deployment URLs
        if: github.event_name == 'pull_request' && success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const denoUrl = '${{ needs.deploy-deno.outputs.url }}';
            const cloudflareUrl = '${{ steps.cloudflare-deploy.outputs.url }}';

            let comment = 'üöÄ **Deployment Complete**\n\n';

            if (cloudflareUrl && cloudflareUrl !== '') {
              comment += `‚úÖ **Cloudflare Pages**: ${cloudflareUrl}\n`;
            }

            if (denoUrl && denoUrl !== '') {
              comment += `‚úÖ **Deno Deploy Functions**: ${denoUrl}\n`;
            }

            comment += '\nüìù Your full-stack application is now live!';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
